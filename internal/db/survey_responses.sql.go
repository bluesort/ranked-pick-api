// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: survey_responses.sql

package db

import (
	"context"
	"database/sql"
)

const anonymizeSurveyResponsesForUser = `-- name: AnonymizeSurveyResponsesForUser :exec
UPDATE survey_responses SET
user_id = NULL
WHERE user_id = ?
`

func (q *Queries) AnonymizeSurveyResponsesForUser(ctx context.Context, userID sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, anonymizeSurveyResponsesForUser, userID)
	return err
}

const countSurveyResponsesForSurvey = `-- name: CountSurveyResponsesForSurvey :one
SELECT COUNT(DISTINCT user_id) FROM survey_responses
WHERE survey_id = ?
`

func (q *Queries) CountSurveyResponsesForSurvey(ctx context.Context, surveyID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countSurveyResponsesForSurvey, surveyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteSurveyResponse = `-- name: DeleteSurveyResponse :exec
DELETE FROM survey_responses
WHERE id = ?
`

func (q *Queries) DeleteSurveyResponse(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSurveyResponse, id)
	return err
}

const deleteSurveyResponsesForSurvey = `-- name: DeleteSurveyResponsesForSurvey :exec
DELETE FROM survey_responses
WHERE survey_id = ?
`

func (q *Queries) DeleteSurveyResponsesForSurvey(ctx context.Context, surveyID int64) error {
	_, err := q.db.ExecContext(ctx, deleteSurveyResponsesForSurvey, surveyID)
	return err
}

const listSurveyResponsesForSurvey = `-- name: ListSurveyResponsesForSurvey :many
SELECT id, survey_id, survey_option_id, rank, user_id, created_at, updated_at FROM survey_responses
WHERE survey_id = ?
ORDER BY id ASC LIMIT 100
`

func (q *Queries) ListSurveyResponsesForSurvey(ctx context.Context, surveyID int64) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, listSurveyResponsesForSurvey, surveyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SurveyResponse
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.SurveyOptionID,
			&i.Rank,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSurveyResponsesForSurveyUser = `-- name: ListSurveyResponsesForSurveyUser :many
SELECT id, survey_id, survey_option_id, rank, user_id, created_at, updated_at FROM survey_responses
WHERE survey_id = ?
AND user_id = ?
ORDER BY rank ASC LIMIT 100
`

type ListSurveyResponsesForSurveyUserParams struct {
	SurveyID int64
	UserID   sql.NullInt64
}

func (q *Queries) ListSurveyResponsesForSurveyUser(ctx context.Context, arg ListSurveyResponsesForSurveyUserParams) ([]SurveyResponse, error) {
	rows, err := q.db.QueryContext(ctx, listSurveyResponsesForSurveyUser, arg.SurveyID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SurveyResponse
	for rows.Next() {
		var i SurveyResponse
		if err := rows.Scan(
			&i.ID,
			&i.SurveyID,
			&i.SurveyOptionID,
			&i.Rank,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSurveyResponse = `-- name: UpdateSurveyResponse :one
UPDATE survey_responses SET
survey_id = coalesce(?2, survey_id),
survey_option_id = coalesce(?3, survey_option_id),
user_id = coalesce(?4, user_id),
rank = coalesce(?5, rank)
WHERE id = ?
RETURNING id, survey_id, survey_option_id, rank, user_id, created_at, updated_at
`

type UpdateSurveyResponseParams struct {
	SurveyID       sql.NullInt64
	SurveyOptionID sql.NullInt64
	UserID         sql.NullInt64
	Rank           sql.NullInt64
	ID             int64
}

func (q *Queries) UpdateSurveyResponse(ctx context.Context, arg UpdateSurveyResponseParams) (SurveyResponse, error) {
	row := q.db.QueryRowContext(ctx, updateSurveyResponse,
		arg.SurveyID,
		arg.SurveyOptionID,
		arg.UserID,
		arg.Rank,
		arg.ID,
	)
	var i SurveyResponse
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.SurveyOptionID,
		&i.Rank,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertSurveyResponse = `-- name: UpsertSurveyResponse :one

INSERT INTO survey_responses (
	survey_id, survey_option_id, user_id, rank
) VALUES (
  ?, ?, ?, ?
)
ON CONFLICT (user_id, survey_option_id) DO UPDATE SET
	survey_id = EXCLUDED.survey_id,
	survey_option_id = EXCLUDED.survey_option_id,
	user_id = EXCLUDED.user_id,
	rank = EXCLUDED.rank
RETURNING id, survey_id, survey_option_id, rank, user_id, created_at, updated_at
`

type UpsertSurveyResponseParams struct {
	SurveyID       int64
	SurveyOptionID int64
	UserID         sql.NullInt64
	Rank           int64
}

// TODO: Add unique survey_responses survey_id,user_id,rank index
func (q *Queries) UpsertSurveyResponse(ctx context.Context, arg UpsertSurveyResponseParams) (SurveyResponse, error) {
	row := q.db.QueryRowContext(ctx, upsertSurveyResponse,
		arg.SurveyID,
		arg.SurveyOptionID,
		arg.UserID,
		arg.Rank,
	)
	var i SurveyResponse
	err := row.Scan(
		&i.ID,
		&i.SurveyID,
		&i.SurveyOptionID,
		&i.Rank,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
